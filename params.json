{"name":"Cl-memcached","tagline":"Fast, thread-safe interface to the Memcached object caching system.","body":"CL-MEMCACHED\r\n============\r\n\r\nCL-MEMCACHED is a **simple**, **fast** & **thread-safe** library to interface with the [memcached](http://www.danga.com/memcached/) object caching system. It implements the Memcached TEXT protocol.\r\n\r\nAccording to the home page :\r\n> *memcached* is a high-performance, distributed memory object caching system, generic in nature, but intended for use in speeding up dynamic web applications by alleviating database load.\r\n\r\nTested on SBCL, CCL & CMUCL.\r\n\r\n-----\r\nGlobal variables\r\n\r\n`*memcache*`\r\n\r\nMost commands have this as a fallback binding. Useful if we are only using one cache or if we want to bind it to a cache and then use it multiple places.\r\n\r\n`*mc-use-pool*`\r\n\r\nIf this is true then the connection pool will be used. On SBCL this is about 3x faster.\r\n\r\n`*mc-default-encoding*`\r\n\r\nBabel is used for encodeing/decoding the data. Memcached expects octets. Default encoding is UTF-8.\r\n\r\n-----\r\n\r\n**make-memcache** &key (ip \"127.0.0.1\") (port 11211) (name \"Memcache\") (pool-size 2)\r\n\r\nMakes a memcached data-structure. We use this for further transactions. This has a inbuilt pool and know how to make new pool items.\r\n\r\n-----\r\n\r\n**mc-set** key data &key (memcache `*memcache*`) (timeout 0) (flags 0) (noreply nil) (cas-unique nil) (mc-use-pool `*mc-use-pool*`)\r\n\r\nStores `data` for the `key` in the `memcache`. The parameters have same value as the memcached server commands.\r\nWe have similar **mc-add**, **mc-replace**, **mc-append**, **mc-prepend** functions available.\r\n\r\n-----\r\n\r\n**mc-cas** key data cas-unique &key (memcache `*memcache*`) (timeout 0) (flags 0) (noreply nil) (external-format `*mc-default-encoding*`) (mc-use-pool `*mc-use-pool*`)\r\n\r\nThis is a Check & Store operation.\r\n\r\n-----\r\n\r\n**mc-get** keys-list &key (memcache `*memcache*`) (mc-use-pool `*mc-use-pool*`)\r\n\r\nReturns a list of lists corresponding to responses to found keys in the keys-list.\r\n\r\n----\r\n\r\n**mc-get+** key-or-list-of-keys &key (memcache `*memcache*`) (mc-use-pool `*mc-use-pool*`)\r\n\r\nThis is a wrapper around `mc-get`. It accepts 1 or many keys. Returns 1 or many `memcache-response` type structures containing all the pieces of the response.\r\n\r\nThe `memcache-response` structure has these slots : `key`, `flags`, `bytes`, `cas-unique`, `data-raw`. All the slot accessors start with `mc-`\r\n\r\n-----\r\n\r\n**mc-data** response &key (external-format `*mc-default-encoding*`)\r\n\r\nTakes the data-raw, which is in octets, and converts it to string using the external-format.\r\n\r\n-----\r\n\r\n**mc-get-value** key &key (memcache `*memcache*`) (mc-use-pool `*mc-use-pool*`) (external-format `*mc-default-encoding*`)\r\n\r\nA wrapper around `mc-data` and `mc-get+`. Give it a key and it gets a string value in return. Misuse is entierly the users responsibility. :)\r\n\r\n-----\r\n\r\n**mc-del** key &key (memcache `*memcache*`) (noreply nil) (mc-use-pool `*mc-use-pool*`)\r\n\r\nDeletes `key` from the cache.\r\n\r\n-----\r\n\r\n**mc-incr** key &key (value 1) (noreply nil) (memcache `*memcache*`) (mc-use-pool `*mc-use-pool*`)\r\n\r\nIncrements `key` in place by value. If `key` not found then will return `NOT_FOUND`.\r\n\r\n------\r\n\r\n**mc-decr** key &key (value 1) (noreply nil) (memcache `*memcache*`) (mc-use-pool `*mc-use-pool*`)\r\n\r\nDecrements `key` by value. If `key` not found then will return `NOT_FOUND`.\r\n\r\n------\r\n\r\n**mc-touch** key expiry-time &key ( *noreply* nil ) ( *memcache* `*memcache*` ) ( *mc-use-pool* `*mc-use-pool*` )\r\n\r\nChange expiry time of `key`.\r\n\r\n-------\r\n\r\n**mc-flush-all** &key ( *delay* 0 ) ( *noreply* nil) ( *memcache* `*memcache*` ) ( *mc-use-pool* `*mc-use-pool*` )\r\n\r\nexpires all the current keys.\r\n\r\n-------\r\n\r\n**mc-version** &key  ( *memcache* `*memcache*` ) ( *mc-use-pool* `*mc-use-pool*` )\r\n\r\nReturns a text string with the version of the memcached server\r\n\r\n-------\r\n\r\n**mc-verbosity** &key ( *level* 1 ) ( *noreply* nil) ( *memcache* `*memcache*` ) ( *mc-use-pool* `*mc-use-pool*` )\r\n\r\nSets the verbosity level of the logging output\r\n\r\n-------\r\n\r\n**mc-stats** &key (memcache `*memcache*`) (noreply nil) (mc-use-pool `*mc-use-pool*`)\r\n\r\nReturns a `alist` of the stats.\r\n\r\n------\r\n\r\n**mc-stats-summary** &key (memcache `*memcache*`)\r\n\r\nPrints all the details from the alist. ;) Not too hot, but hey.\r\n\r\n\r\n-----\r\n\r\nExample Usage for testing.\r\n```\r\nCL-USER> (require 'cl-memcached)\r\nNIL\r\n\r\nCL-MEMCACHED> (in-package :cl-memcached)\r\n#<PACKAGE \"CL-MEMCACHED\">\r\n\r\nCL-MEMCACHED> (setf *memcache* (make-memcache))\r\n#<MEMCACHED-SERVER Name:Memcache IP:127.0.0.1 Port:11211 >\r\n\r\nCL-MEMCACHED> (mc-quick-test \"foo\" \"bar\")\r\nSuccess SET\r\nSuccess GET\r\nNIL\r\n\r\nCL-MEMCACHED> (mc-set \"t1\" \"oooooooooooooooooooooo\")\r\nSTORED\r\n:INTERNAL\r\n\r\nCL-MEMCACHED> (mc-get+ \"t1\")\r\n#<MEMCACHED-RESPONSE Key:t1 Data-Length:22 >\r\n\r\nCL-MEMCACHED> (describe *)\r\n#<MEMCACHED-RESPONSE Key:t1 Data-Length:22 >\r\n  [structure-object]\r\n\r\nSlots with :INSTANCE allocation:\r\n  KEY         = \"t1\"\r\n  FLAGS       = \"0\"\r\n  BYTES       = 22\r\n  CAS-UNIQUE  = NIL\r\n  DATA-RAW    = #(111 111 111 111 111 111 111 111 111 111 111 111 111 111 111 111 111..\r\n; No value\r\n\r\nCL-MEMCACHED> (mc-data (mc-get+ \"t1\"))\r\n\"oooooooooooooooooooooo\"\r\n\r\nCL-MEMCACHED> (mc-get-value \"t1\")\r\n\"oooooooooooooooooooooo\"\r\n\r\nCL-MEMCACHED> (mc-set \"t2\" \"0\")\r\nSTORED\r\n:INTERNAL\r\n\r\nCL-MEMCACHED> (mc-incr \"t3\")\r\nNOT_FOUND\r\n\r\nCL-MEMCACHED> (mc-incr \"t2\")\r\n1\r\n1\r\n\r\nCL-MEMCACHED> (mc-incr \"t2\")\r\n2\r\n1\r\n\r\nCL-MEMCACHED> (mc-decr \"t2\")\r\n1\r\n1\r\n\r\n```\r\n\r\nAUTHORS:\r\n\r\nAbhijit 'quasi' Rao <quasi@quasilabs.in>\r\n\r\n\r\nDEPENDENCIES:\r\n\r\n* usocket http://www.cliki.net/usockes\r\n* split-sequence http://www.cliki.net/SPLIT-SEQUENCE\r\n* babel http://common-lisp.net/project/babel/\r\n* pooler https://github.com/quasi/pooler\r\n\r\nNote :\r\nThe http://common-lisp.net/project/cl-memcached/ is the homepage. But the version there is older and the documentation out of date. I have lost the creds, :-). Till I manage to set that right please ignore that one.\r\n\r\nBenchmark\r\n---------\r\nHost OS : OSX 10.8.4\r\nDataset: 1024 bytes (1kb) text string. Repeat 10000 times.\r\n```\r\n|-------------------+------------------+---------------+------------------+---------------|\r\n| implementation    | SET without pool | SET with pool | GET without pool | GET with pool |\r\n|-------------------+------------------+---------------+------------------+---------------|\r\n| SBCL 1.1.10       |            4.942 |         0.713 |            4.905 |         0.690 |\r\n| CCL 1.9-r15759    |            4.711 |         0.847 |            4.506 |         0.648 |\r\n| CMUCL 20D Unicode |            4.460 |         0.970 |            4.290 |         0.810 |\r\n|-------------------+------------------+---------------+------------------+---------------|\r\n| Dalli on Ruby 1.9 |                  |         0.957 |                  |         1.033 |\r\n|-------------------+------------------+---------------+------------------+---------------|\r\n```\r\nWhen we do not use the pool we make a new socket connection every time.\r\n\r\nThe Ruby 'dalli' client, which implements the binary protocol, uses the same socket (I think) so this should be comparable with our with-pool.\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}